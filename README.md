# honeworkgroup-116  
The group 116  
这是网络空间安全创新创业第116小组的作业仓库  
该作业为独自完成，参考教程在project文档里有说明  
> # Project1  
>> - # Project1实验说明    
>>   - ## 生日概述  
>>     - 生日攻击是一种密码学攻击方法，利用生日悖论来寻找两个不同的输入，它们产生相同的哈希值或者其他指纹值。该攻击方法可以用于破解哈希函数的强度或者构造冲突。  
>>   - ## 实现方式  
>>     - ### 步骤一:选择哈希算法和哈希值长度  
>>       - 首先，选择要攻击的哈希算法和相应的哈希值长度。通常，生日攻击的难度随着哈希值长度的增加而增加。  
>>     - ### 步骤二:生成随机字符串  
>>       - 实现一个函数来生成随机字符串，以用作攻击过程中的输入。随机字符串的长度应该足够长，以提高碰撞的概率。  
>>     - ### 步骤三:构造哈希前缀集合  
>>       - 创建一个空的哈希前缀集合，用于存储已经计算过的哈希前缀。  
>>      - ### 步骤四:进行生日攻击  
>>       - 1、生成一个随机字符串。  
>>       - 2、对随机字符串进行哈希计算，获取其哈希值。  
>>       - 3、提取哈希值的前缀（长度根据选定的哈希算法和长度确定）。  
>>       - 4、检查哈希前缀是否存在于哈希前缀集合中。  
>>       - 5、如果存在，说明找到了两个不同的字符串，它们的哈希前缀相同，发现了碰撞。  
>>       - 6、如果不存在，将哈希前缀添加到哈希前缀集合中，继续下一轮循环。  
>>     - ### 步骤五:处理碰撞结果  
>>       - 一旦发现碰撞，可以获取碰撞的字符串和对应的哈希值，用于进一步分析和验证攻击的成功性。    
>>   - ## 运行效果  
>>     - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/b0071d01-2143-493c-b789-4279eec195ac)
>>     - 运行时间 233ms
>>     - CPU：AMD Ryzen 9 5900HX with Radeon Graphics           3.30 GHz
> # Project2
>> - # Project2实验说明
>>   - ## SM3
>>     -   `ShangMi 3` (SM3)是中国国家标准中使用的加密散列函数。国家密码管理局于2010-12-17以“GM/T 0004-2012: SM3密码学哈希算法”的名称发布。
>>     -   `SM3`用于实现数字签名、消息验证码和伪随机数生成器。该算法是公开的，在安全性和效率方面被认为与SHA-256相似。SM3与传输层安全一起使用。
>>   - ## Rho
>>     - https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm
>>     - Rho 方法是一个简单的碰撞搜索算法，用于在SM3哈希函数中找到两个不同的消息（m1 和 m2），它们的前 exm 位SM3哈希值相同。
>>     - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/f00c34a0-9ce0-44da-a13f-dac069e14e5b)
>>     - 下面将介绍 Rho 方法的实现过程：
>>       - 输入参数 `exm`：这个参数指定了要搜索碰撞的位数。在示例代码中，`exm` 设置为 16，表示搜索前16位的碰撞。
>>       - 随机生成初始消息 `x`：首先，在范围 [0, 2^(exm+1)-1] 内随机生成一个整数，然后将其转换为16进制字符串作为初始消息 `x`。
>>       - 对 `x` 进行迭代：通过调用 `SM3.SM3(x)`，计算消息 `x` 的SM3哈希值 `x_1`。然后再次计算 `x_1` 的SM3哈希值，得到 `x_2`。
>>       - 碰撞搜索循环：在 `x_1` 和 `x_2` 的前 `num` 位（num 为 `exm` 的1/4）不相同的情况下，对 `x_1` 和 `x_2` 进行迭代，直到找到两者前 `num` 位相同的情况。此时得到的 `x_1` 和 `x_2` 就是碰撞消息。
>>       - 返回结果：找到碰撞后，返回 `x_1` 和 `x_2` 的前 `num` 位SM3哈希值（表示为 `col`），以及 `x_1` 和 `x_2` 的原始消息。
>>     - 在主程序中，使用 `Rho` 方法搜索前16位的碰撞，并计算执行时间。该算法只是一个简单的示例，不适用于实际应用。
>>   - ## 运行效果
>>   - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/6cf43a83-bf7e-4dfd-ba7c-834f7bad07df)
>>   - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/3381c586-1929-461e-b7ce-904b0ccd8394)
>>   - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/ee8b1254-21b0-404e-bd3e-9babfacbcd10)
>>   - 16bit碰撞平均运行时间：143.928s
>>   - CPU：AMD Ryzen 9 5900HX with Radeon Graphics           3.30 GHz
> # Project3
>> - # Project3实验说明
>>   - ## 长度攻击
>>     - 在密码学和计算机安全中，长度扩展攻击（英语：Length extension attacks）是指一种针对特定加密散列函数的攻击手段，攻击者可以利用H（消息1）和消息1的长度，不知道消息1内容的情形下，将攻击者控制的消息2计算出H（消息1 ‖ 消息2）。
>>     - 该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。注意，由于密钥散列消息认证码（HMAC）并未采取 H(密钥 ∥ 消息) 的构造方式，因此不会受到此类攻击的影响（如HMAC-MD5、HMAC-SHA1）。SHA-3算法对此攻击免疫
>>   - ## 实现方式
>>     -<img width="688" alt="image" src="https://github.com/2562908360/honeworkgroup-116/assets/97723386/4bf51038-4738-4694-986e-e9a603d5f3b5">
 
>>     - 计算原始消息的SM3哈希值：`h_m = SM3.SM3(msg)`
>>     - 将SM3哈希值分割成8个32位整数：`Hm = [int(h_m[i * 8:i * 8 + 8], 16) for i in range(8)]`
>>     - 计算总消息位长并表示为16进制字符串：`len_e = hex((n + len(ext) ) * 4)[2:]`。这里的 `n` 是原始消息经过填充后的16进制数个数。
>>     - 补全表示总消息位长的16进制字符串，使其长度为16位：`len_e = (16-len(len_e))*'0'+len_e`
>>     - 根据扩展部分 `ext` 的长度，构造要添加的新数据并附加到 `ext` 后面。具体的添加过程是，如果 `ext` 的长度对128取模后大于112，则在 `ext` 后面添加足够的零字符 '0'，使其长度满足特定要求，然后再将表示总消息位长的16进制字符串 `len_e` 添加到 `ext` 的末尾。
>>     - 将构造的扩展部分 `ext` 进行分组，即将其转换为一系列16进制数。
>>     - 初始化 `V` 列表为 `Hm`：`V = [Hm]`。`V` 列表用于存储压缩函数输出的中间状态。
>>     - 通过循环，将分组后的 `ext` 逐个与 `V` 列表中的最后一个元素（即上一轮的中间状态）一起传入压缩函数 `SM3.CF(V, ext_g, i)` 进行计算，并将计算得到的中间状态添加到 `V` 列表中：`for i in range(len_ext_g): V.append(SM3.CF(V,ext_g,i))`
>>     - 最终，`V` 列表中的最后一个元素即为构造的新消息的哈希值，将它转换为十六进制字符串并返回：`res = '' for x in V[len_ext_g]: res += hex(x)[2:] return res`。
>>     - 这样，长度扩展攻击就完成了，通过构造新消息并保持相同的哈希值，攻击者可以违反原始消息的完整性和认证。
>>   - ## 运行效果
>>   - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/2bb69c40-5cdb-4e62-b820-75eb379fd4da)
>>   - 运行速度：42ms
>>   - CPU：AMD Ryzen 9 5900HX with Radeon Graphics 3.30 GHz





> # Project5  
>> - # Project5实验说明
>>   - ## Merkle Tree
>>     - Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。
>>     - Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree,如下图所示：
>>     - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/a475be82-eb59-4cec-825e-3c72366c0d20)
>>   - ## 实现方式
>>     - 默克尔树节点定义：定义了一个 MerkleTreeNode 类，其中包含了左子节点、右子节点、父节点以及节点的值（哈希值）等属性。这个类用于构建树的节点。
>>     - 默克尔树结构定义：定义了一个 MerkleTree 类，其中包含了叶子节点列表、根节点以及用于存储整个树中节点值的 mtlist 列表。MerkleTree 类有以下几个重要方法：
>>       - `sha256_leaf(value)`: 这个方法用于计算叶子节点的哈希值。它对节点的值进行了级联操作，并使用 SHA-256 哈希算法对级联后的字符串进行哈希计算。
>>       - `sha256_node(value)`: 这个方法用于计算中间节点的哈希值。同样，它对节点的值进行了级联操作，并使用 SHA-256 哈希算法对级联后的字符串进行哈希计算。
>>       - `create_MerkleTree()`: 这个方法用于构建默克尔树。它先创建叶子节点，并对每个叶子节点计算其哈希值。然后，从叶子节点开始，逐层构建中间节点，直到生成根节点。中间节点的哈希值是由其两个子节点的哈希值计算得到。
>>       - `Inorder(root)`: 这个方法用于中序遍历整个默克尔树，得到树中所有节点的值，并存储在 mtlist 列表中。
>>       - `proof(root, nodevalue)`: 这个方法用于验证给定的节点值是否存在于默克尔树中。它通过调用 Inorder 方法得到整个树的节点值列表，并检查给定的节点值是否在其中，从而判断节点是否在树中。
>>     - 主程序部分：在主程序中，首先生成 10**5 个随机整数作为叶子节点的值，并将其转换为对应的十六进制表示。然后，利用这些叶子节点值构建默克尔树，并输出树的根节点的值。接着，验证一些随机生成的节点值是否在默克尔树中，并输出验证结果。
>>   - ## 运行效果:
>>     - ![image](https://github.com/2562908360/honeworkgroup-116/assets/97723386/abf4e272-793a-403a-8925-dd163d6fbe00)
>>     - 运行速度 1.009s
>>     - CPU：AMD Ryzen 9 5900HX with Radeon Graphics           3.30 GHz
  




